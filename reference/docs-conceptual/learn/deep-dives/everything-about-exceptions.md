---
title: Alles, was Sie schon immer über Ausnahmen wissen wollten
description: Die Fehlerbehandlung ist nur ein Teil der Aufgaben beim Schreiben von Code.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: 3ecb1669fa8d58bc742d4e8e77051b3ace4452a0
ms.sourcegitcommit: 4a40e3ea3601c02366be3495a5dcc7f4cac9f1ea
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/03/2020
ms.locfileid: "84337181"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="92183-103">Alles, was Sie schon immer über Ausnahmen wissen wollten</span><span class="sxs-lookup"><span data-stu-id="92183-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="92183-104">Die Fehlerbehandlung ist nur ein Teil der Aufgaben beim Schreiben von Code.</span><span class="sxs-lookup"><span data-stu-id="92183-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="92183-105">Wir können häufig die Bedingungen für erwartetes Verhalten überprüfen und validieren.</span><span class="sxs-lookup"><span data-stu-id="92183-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="92183-106">Wenn ein unerwartetes Verhalten auftritt, wird die Ausnahmebehandlung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="92183-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="92183-107">Sie können die Ausnahmen, die durch den Code anderer Personen generiert wurden, leicht behandeln, oder Sie können Ihre eigenen Ausnahmen generieren, die andere behandeln können.</span><span class="sxs-lookup"><span data-stu-id="92183-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="92183-108">Die [Originalversion][] dieses Artikels ist im Blog von [@KevinMarquette][] erschienen.</span><span class="sxs-lookup"><span data-stu-id="92183-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="92183-109">Das PowerShell-Team dankt Kevin Marquette, dass er diesen Inhalt mit uns teilt.</span><span class="sxs-lookup"><span data-stu-id="92183-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="92183-110">Weitere Informationen finden Sie in seinem Blog auf [PowerShellExplained.com][].</span><span class="sxs-lookup"><span data-stu-id="92183-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="92183-111">Grundlegende Terminologie</span><span class="sxs-lookup"><span data-stu-id="92183-111">Basic terminology</span></span>

<span data-ttu-id="92183-112">Wir müssen einige grundlegende Begriffe klären, bevor wir uns mit diesem Thema befassen.</span><span class="sxs-lookup"><span data-stu-id="92183-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="92183-113">Ausnahme</span><span class="sxs-lookup"><span data-stu-id="92183-113">Exception</span></span>

<span data-ttu-id="92183-114">Eine Ausnahme ist wie ein Ereignis, das ausgelöst wird, wenn die normale Fehlerbehandlung das Problem nicht beheben kann.</span><span class="sxs-lookup"><span data-stu-id="92183-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="92183-115">Der Versuch, eine Zahl durch 0 zu teilen oder nicht genügend Arbeitsspeicher zu haben, sind Beispiele für Ereignisse, die eine Ausnahme erzeugen.</span><span class="sxs-lookup"><span data-stu-id="92183-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="92183-116">Manchmal erstellt der Autor des Codes, den Sie verwenden, Ausnahmen für bestimmte Probleme, falls diese auftreten.</span><span class="sxs-lookup"><span data-stu-id="92183-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="92183-117">Throw und Catch</span><span class="sxs-lookup"><span data-stu-id="92183-117">Throw and Catch</span></span>

<span data-ttu-id="92183-118">Wenn eine Ausnahme auftritt, sagen wir, dass eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="92183-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="92183-119">Um eine ausgelöste Ausnahme zu behandeln, müssen Sie sie abfangen.</span><span class="sxs-lookup"><span data-stu-id="92183-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="92183-120">Wenn eine Ausnahme ausgelöst und nicht abgefangen wird, wird die Ausführung des Skripts beendet.</span><span class="sxs-lookup"><span data-stu-id="92183-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="92183-121">Die Aufrufliste</span><span class="sxs-lookup"><span data-stu-id="92183-121">The call stack</span></span>

<span data-ttu-id="92183-122">Die Aufrufliste ist die Liste der Funktionen, die sich gegenseitig aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="92183-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="92183-123">Wenn eine Funktion aufgerufen wird, wird Sie zum Stapel oder dem Anfang der Liste hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="92183-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="92183-124">Wenn die Funktion beendet oder zurückgegeben wird, wird Sie aus dem Stapel entfernt.</span><span class="sxs-lookup"><span data-stu-id="92183-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="92183-125">Wenn eine Ausnahme ausgelöst wird, wird diese Aufrufliste eingecheckt, damit sie von einem Ausnahmehandler abgefangen werden kann.</span><span class="sxs-lookup"><span data-stu-id="92183-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="92183-126">Fehler mit und ohne Abbruch</span><span class="sxs-lookup"><span data-stu-id="92183-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="92183-127">Eine Ausnahme ist im Allgemeinen ein Fehler mit Abbruch.</span><span class="sxs-lookup"><span data-stu-id="92183-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="92183-128">Eine ausgelöste Ausnahme wird entweder abgefangen oder beendet die aktuelle Ausführung.</span><span class="sxs-lookup"><span data-stu-id="92183-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="92183-129">Standardmäßig wird ein Fehler ohne Abbruch durch `Write-Error` generiert, und dem Ausgabestream wird ein Fehler hinzugefügt, ohne dass eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="92183-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="92183-130">Ich weise darauf hin, da `Write-Error` und andere Fehler ohne Abbruch `catch` nicht auslösen.</span><span class="sxs-lookup"><span data-stu-id="92183-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="92183-131">Behalten einer Ausnahme</span><span class="sxs-lookup"><span data-stu-id="92183-131">Swallowing an exception</span></span>

<span data-ttu-id="92183-132">Dies tritt auf, wenn Sie einen Fehler abfangen, um ihn zu unterdrücken.</span><span class="sxs-lookup"><span data-stu-id="92183-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="92183-133">Gehen Sie dabei vorsichtig vor, da dies das Troubleshooting sehr schwierig machen kann.</span><span class="sxs-lookup"><span data-stu-id="92183-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="92183-134">Grundlegende Befehlssyntax</span><span class="sxs-lookup"><span data-stu-id="92183-134">Basic command syntax</span></span>

<span data-ttu-id="92183-135">Hier finden Sie eine kurze Übersicht über die in PowerShell verwendete grundlegende Syntax für die Ausnahmebehandlung.</span><span class="sxs-lookup"><span data-stu-id="92183-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="92183-136">Throw</span><span class="sxs-lookup"><span data-stu-id="92183-136">Throw</span></span>

<span data-ttu-id="92183-137">Zum Erstellen eines eigenen Ausnahmeereignisses, lösen wir eine Ausnahme mit dem Schlüsselwort `throw` aus.</span><span class="sxs-lookup"><span data-stu-id="92183-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="92183-138">Dadurch wird eine Laufzeitausnahme erstellt, die ein Fehler mit Abbruch ist.</span><span class="sxs-lookup"><span data-stu-id="92183-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="92183-139">Sie wird von einem `catch` in einer Aufruffunktion behandelt oder beendet das Skript mit einer Meldung wie dieser.</span><span class="sxs-lookup"><span data-stu-id="92183-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="92183-140">Write-Error -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="92183-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="92183-141">Ich habe bereits erwähnt, dass `Write-Error` nicht standardmäßig einen Fehler mit Abbruch auslöst.</span><span class="sxs-lookup"><span data-stu-id="92183-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="92183-142">Wenn Sie `-ErrorAction Stop` angeben, generiert `Write-Error` einen Fehler mit Abbruch, der mit einem `catch` behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="92183-142">If you specify `-ErrorAction Stop`, `Write-Error`generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="92183-143">Vielen Dank an Lee Daily, der daran erinnert hat, dass man `-ErrorAction Stop` auch auf diese Weise verwenden kann.</span><span class="sxs-lookup"><span data-stu-id="92183-143">Thank you to Lee Daily for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="92183-144">Cmdlet -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="92183-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="92183-145">Wenn Sie `-ErrorAction Stop` in einer beliebigen erweiterten Funktion oder einem Cmdlet angeben, werden alle `Write-Error`-Anweisungen in Fehler mit Abbruch umgewandelt, durch die die Ausführung angehalten wird oder die von einem `catch` behandelt werden können.</span><span class="sxs-lookup"><span data-stu-id="92183-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="92183-146">Try/Catch</span><span class="sxs-lookup"><span data-stu-id="92183-146">Try/Catch</span></span>

<span data-ttu-id="92183-147">Die Ausnahmebehandlung in PowerShell (und vielen anderen Sprachen) funktioniert so, dass Sie zuerst einen `try`-Vorgang für einen Codeabschnitt ausführen. Wenn dadurch ein Fehler ausgelöst wird, können Sie einen `catch`-Vorgang ausführen.</span><span class="sxs-lookup"><span data-stu-id="92183-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="92183-148">Hier ist ein kurzes Beispiel.</span><span class="sxs-lookup"><span data-stu-id="92183-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="92183-149">Das `catch`-Skript wird nur ausgeführt, wenn ein Fehler mit Abbruch vorliegt.</span><span class="sxs-lookup"><span data-stu-id="92183-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="92183-150">Wenn `try` ordnungsgemäß ausgeführt wird, wird zu `catch` übergegangen.</span><span class="sxs-lookup"><span data-stu-id="92183-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="92183-151">Try/Finally</span><span class="sxs-lookup"><span data-stu-id="92183-151">Try/Finally</span></span>

<span data-ttu-id="92183-152">Manchmal müssen Sie einen Fehler nicht behandeln, benötigen aber trotzdem Code, der ausgeführt wird, wenn eine Ausnahme auftritt oder nicht.</span><span class="sxs-lookup"><span data-stu-id="92183-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="92183-153">Ein `finally`-Skript macht genau das.</span><span class="sxs-lookup"><span data-stu-id="92183-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="92183-154">Im Folgenden finden Sie ein Beispiel:</span><span class="sxs-lookup"><span data-stu-id="92183-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="92183-155">Jedes Mal, wenn Sie eine Ressource öffnen oder eine Verbindung mit dieser herstellen, sollten Sie sie auch schließen.</span><span class="sxs-lookup"><span data-stu-id="92183-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="92183-156">Wenn `ExecuteNonQuery()` eine Ausnahme auslöst, wird die Verbindung nicht geschlossen.</span><span class="sxs-lookup"><span data-stu-id="92183-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="92183-157">Hier ist derselbe Code in einem `try/finally`-Block.</span><span class="sxs-lookup"><span data-stu-id="92183-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="92183-158">In diesem Beispiel wird die Verbindung geschlossen, wenn ein Fehler vorliegt.</span><span class="sxs-lookup"><span data-stu-id="92183-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="92183-159">Sie wird auch geschlossen, wenn kein Fehler vorliegt.</span><span class="sxs-lookup"><span data-stu-id="92183-159">It also is closed if there's no error.</span></span> <span data-ttu-id="92183-160">Das `finally`-Skript wird jedes Mal ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="92183-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="92183-161">Da die Ausnahme nicht abgefangen wird, wird Sie weiterhin in der Aufrufliste nach oben weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="92183-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="92183-162">Try/Catch/Finally</span><span class="sxs-lookup"><span data-stu-id="92183-162">Try/Catch/Finally</span></span>

<span data-ttu-id="92183-163">Es ist durchaus zulässig, `catch` und `finally` in Kombination zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="92183-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="92183-164">In den meisten Fällen verwenden Sie nur eine der Optionen, aber es gibt möglicherweise Szenarios, in denen Sie beide verwenden.</span><span class="sxs-lookup"><span data-stu-id="92183-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="92183-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="92183-165">$PSItem</span></span>

<span data-ttu-id="92183-166">Da wir nun die Grundlagen kennen, können wir uns etwas genauer mit dem Thema beschäftigen.</span><span class="sxs-lookup"><span data-stu-id="92183-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="92183-167">Innerhalb des `catch`-Blocks gibt es eine automatische Variable (`$PSItem` oder `$_`) vom Typ `ErrorRecord`, die die Details zur Ausnahme enthält.</span><span class="sxs-lookup"><span data-stu-id="92183-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="92183-168">Hie ist eine kurze Übersicht über einige der wichtigsten Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="92183-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="92183-169">In diesen Beispielen wurde in `ReadAllText` zum Generieren dieser Ausnahme ein ungültiger Pfad verwendet.</span><span class="sxs-lookup"><span data-stu-id="92183-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="92183-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="92183-170">PSItem.ToString()</span></span>

<span data-ttu-id="92183-171">Dadurch erhalten Sie die übersichtlichste Meldung, die Sie für die Protokollierung und allgemeine Ausgabe verwenden können.</span><span class="sxs-lookup"><span data-stu-id="92183-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="92183-172">`ToString()` wird automatisch aufgerufen, wenn `$PSItem` in eine Zeichenfolge eingefügt wird.</span><span class="sxs-lookup"><span data-stu-id="92183-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="92183-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="92183-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="92183-174">Diese Eigenschaft enthält zusätzliche von PowerShell gesammelte Informationen über die Funktion oder das Skript, in dem die Ausnahme ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="92183-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="92183-175">Hier ist die `InvocationInfo` aus der Beispielausnahme, die ich erstellt habe.</span><span class="sxs-lookup"><span data-stu-id="92183-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="92183-176">Die wichtigen Details zeigen hier den `ScriptName`, die `Line` des Codes und die `ScriptLineNumber`, wo der Aufruf begann.</span><span class="sxs-lookup"><span data-stu-id="92183-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="92183-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="92183-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="92183-178">Diese Eigenschaft zeigt die Reihenfolge der Funktionsaufrufe an, mit der Sie den Code erhalten haben, in dem die Ausnahme generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="92183-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="92183-179">Ich führe nur Aufrufe von Funktionen im gleichen Skript durch, aber dies würde die Aufrufe nachverfolgen, wenn mehrere Skripts beteiligt wären.</span><span class="sxs-lookup"><span data-stu-id="92183-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="92183-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="92183-180">$PSItem.Exception</span></span>

<span data-ttu-id="92183-181">Dies ist die tatsächlich ausgelöste Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="92183-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="92183-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="92183-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="92183-183">Dies ist die allgemeine Meldung, in der die Ausnahme beschrieben wird, und ein guter Startpunkt beim Troubleshooting.</span><span class="sxs-lookup"><span data-stu-id="92183-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="92183-184">Die meisten Ausnahmen verfügen über eine Standardmeldung. Diese können jedoch benutzerdefiniert angepasst werden, wenn die Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="92183-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="92183-185">Dies ist auch die Meldung, die beim Aufrufen von `$PSItem.ToString()` zurückgegeben wird, wenn nichts im `ErrorRecord` festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="92183-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="92183-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="92183-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="92183-187">Ausnahmen können innere Ausnahmen enthalten.</span><span class="sxs-lookup"><span data-stu-id="92183-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="92183-188">Dies ist häufig der Fall, wenn der Code, den Sie aufrufen, eine Ausnahme abfängt und eine andere Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="92183-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="92183-189">Die ursprüngliche Ausnahme wird in der neuen Ausnahme eingefügt.</span><span class="sxs-lookup"><span data-stu-id="92183-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="92183-190">Ich werde dies später noch einmal ansprechen, wenn es um das erneute Auslösen von Ausnahmen geht.</span><span class="sxs-lookup"><span data-stu-id="92183-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="92183-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="92183-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="92183-192">Das ist die `StackTrace` für die Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="92183-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="92183-193">Ich habe oben eine `ScriptStackTrace` gezeigt, aber diese ist für die Aufrufe von verwaltetem Code vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="92183-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="92183-194">Sie erhalten diese Stapelüberwachung nur, wenn das Ereignis durch verwalteten Code ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="92183-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="92183-195">Ich rufe direkt eine .NET Framework-Funktion auf. Das ist also alles, was wir in diesem Beispiel sehen können.</span><span class="sxs-lookup"><span data-stu-id="92183-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="92183-196">Wenn Sie sich eine Stapelüberwachung ansehen, suchen Sie im Allgemeinen nach der Stelle, an der Ihr Code aufhört und die Systemaufrufe beginnen.</span><span class="sxs-lookup"><span data-stu-id="92183-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="92183-197">Arbeiten mit Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="92183-197">Working with exceptions</span></span>

<span data-ttu-id="92183-198">Zum Thema Ausnahmen gehört mehr als die grundlegende Syntax und Ausnahmeeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="92183-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="92183-199">Abfangen typisierter Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="92183-199">Catching typed exceptions</span></span>

<span data-ttu-id="92183-200">Sie können auswählen, welche Ausnahmen Sie abfangen wollen.</span><span class="sxs-lookup"><span data-stu-id="92183-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="92183-201">Ausnahmen haben einen Typ, und Sie können den Typ der Ausnahme angeben, die Sie abfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="92183-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="92183-202">Der Ausnahmetyp wird für jeden `catch`-Block solange geprüft, bis ein solcher Typ gefunden wird, der mit der Ausnahme übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="92183-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="92183-203">Es ist wichtig zu wissen, dass Ausnahmen von anderen Ausnahmen Werte übernehmen können.</span><span class="sxs-lookup"><span data-stu-id="92183-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="92183-204">Im Beispiel oben übernimmt `FileNotFoundException` Werte von `IOException`.</span><span class="sxs-lookup"><span data-stu-id="92183-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="92183-205">Wenn also zuerst `IOException` aufgetreten ist, würde das stattdessen aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="92183-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="92183-206">Auch bei mehreren Übereinstimmungen wird nur ein Catch-Block aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="92183-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="92183-207">Wenn wir eine `System.IO.PathTooLongException` hätten, würde die `IOException` übereinstimmen. Hätten wir aber eine `InsufficientMemoryException`, dann würde diese nicht abgefangen und im Stapel nach oben weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="92183-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="92183-208">Gleichzeitiges Abfangen mehrerer Typen</span><span class="sxs-lookup"><span data-stu-id="92183-208">Catch multiple types at once</span></span>

<span data-ttu-id="92183-209">Es können mehrere Ausnahmetypen mit der gleichen `catch`-Anweisung abgefangen werden.</span><span class="sxs-lookup"><span data-stu-id="92183-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="92183-210">Vielen Dank an `/u/Sheppard_Ra` für diesen Vorschlag.</span><span class="sxs-lookup"><span data-stu-id="92183-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="92183-211">Auslösen typisierter Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="92183-211">Throwing typed exceptions</span></span>

<span data-ttu-id="92183-212">Sie können in PowerShell typisierte Ausnahmen auslösen.</span><span class="sxs-lookup"><span data-stu-id="92183-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="92183-213">Anstatt `throw` mit einer Zeichenfolge aufrufen:</span><span class="sxs-lookup"><span data-stu-id="92183-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="92183-214">Verwenden Sie einen Ausnahmebeschleuniger wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="92183-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="92183-215">Wenn Sie diese Möglichkeit verwenden, müssen Sie jedoch eine Meldung angeben.</span><span class="sxs-lookup"><span data-stu-id="92183-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="92183-216">Sie können auch eine neue Instanz einer Ausnahme erstellen, die ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="92183-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="92183-217">In diesem Fall ist die Meldung optional, da das System über Standardmeldungen für alle integrierten Ausnahmen verfügt.</span><span class="sxs-lookup"><span data-stu-id="92183-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="92183-218">Wenn Sie nicht PowerShell 5.0 oder höher verwenden, müssen Sie den älteren Ansatz `New-Object` verwenden.</span><span class="sxs-lookup"><span data-stu-id="92183-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="92183-219">Wenn Sie eine typisierte Ausnahme verwenden, können Sie (oder andere) die Ausnahme nach Typ abfangen, wie im vorherigen Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="92183-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="92183-220">Write-Error -Exception</span><span class="sxs-lookup"><span data-stu-id="92183-220">Write-Error -Exception</span></span>

<span data-ttu-id="92183-221">Wir können diese typisierten Ausnahmen zu `Write-Error` hinzufügen, und wir können weiterhin einen `catch`-Vorgang für die Fehler nach Ausnahmetyp durchführen.</span><span class="sxs-lookup"><span data-stu-id="92183-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="92183-222">Verwenden Sie `Write-Error` wie in diesen Beispielen:</span><span class="sxs-lookup"><span data-stu-id="92183-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="92183-223">Dann können wir sie wie folgt abfangen:</span><span class="sxs-lookup"><span data-stu-id="92183-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="92183-224">Die lange Liste der .NET-Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="92183-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="92183-225">Ich habe mithilfe der [Reddit/r/PowerShell-Community][] eine Masterliste mit Hunderten .NET-Ausnahmen als Ergänzung für diesen Beitrag zusammengestellt.</span><span class="sxs-lookup"><span data-stu-id="92183-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="92183-226">[Die lange Liste der .NET-Ausnahmen][]</span><span class="sxs-lookup"><span data-stu-id="92183-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="92183-227">Ich durchsuche diese Liste zunächst nach Ausnahme, die meiner Meinung nach gut zu meiner Situation passen.</span><span class="sxs-lookup"><span data-stu-id="92183-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="92183-228">Versuchen Sie, Ausnahmen im Basis-`System`-Namespace zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="92183-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="92183-229">Ausnahmen sind Objekte</span><span class="sxs-lookup"><span data-stu-id="92183-229">Exceptions are objects</span></span>

<span data-ttu-id="92183-230">Wenn Sie damit anfangen, viele typisierte Ausnahmen zu verwenden, müssen Sie daran denken, dass es sich um-Objekte handelt.</span><span class="sxs-lookup"><span data-stu-id="92183-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="92183-231">Verschiedene Ausnahmen haben unterschiedliche Konstruktoren und Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="92183-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="92183-232">Wenn wir in der [FileNotFoundException][]-Dokumentation nach `System.IO.FileNotFoundException`suchen, sehen wir, dass wir eine Meldung und einen Dateipfad übergeben können.</span><span class="sxs-lookup"><span data-stu-id="92183-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="92183-233">Und es gibt eine `FileName`-Eigenschaft, die diesen Dateipfad verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="92183-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="92183-234">Andere Konstruktoren und Objekteigenschaften finden Sie in der [.NET-Dokumentation][].</span><span class="sxs-lookup"><span data-stu-id="92183-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="92183-235">Erneutes Auslösen einer Ausnahme</span><span class="sxs-lookup"><span data-stu-id="92183-235">Re-throwing an exception</span></span>

<span data-ttu-id="92183-236">Wenn Sie in Ihrem `catch`-Block lediglich einen `throw`-Vorgang für dieselbe Ausnahme durchführen möchten, dann führen Sie keinen `catch`-Vorgang durch.</span><span class="sxs-lookup"><span data-stu-id="92183-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="92183-237">Sie sollten nur einen `catch`-Vorgang für eine Ausnahme durchführen, die Sie behandeln wollen, oder eine Aktion ausführen, wenn sie auftritt.</span><span class="sxs-lookup"><span data-stu-id="92183-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="92183-238">Manchmal möchte man eine Aktion für eine Ausnahme ausführen, die Ausnahme aber erneut auslösen, damit ein nachgeschalteter Prozess sie behandeln kann.</span><span class="sxs-lookup"><span data-stu-id="92183-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="92183-239">Wir könnten eine Meldung schreiben oder das Problem in der Nähe der Stelle protokollieren, an der wir es entdeckt haben, das Problem aber weiter oben im Stapel behandeln.</span><span class="sxs-lookup"><span data-stu-id="92183-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="92183-240">Interessanterweise können wir `throw` innerhalb des `catch` aufrufen, und die aktuelle Ausnahme wird erneut ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="92183-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="92183-241">Wir möchten die Ausnahme erneut auslösen, um die ursprünglichen Ausführungsinformationen wie Quellskript und Zeilennummer beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="92183-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="92183-242">Wenn an dieser Stelle eine neue Ausnahme ausgelöst wird, wird ausgeblendet, wo die Ausnahme begonnen hat.</span><span class="sxs-lookup"><span data-stu-id="92183-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="92183-243">Erneutes Auslösen einer neuen Ausnahme</span><span class="sxs-lookup"><span data-stu-id="92183-243">Re-throwing a new exception</span></span>

<span data-ttu-id="92183-244">Wenn Sie eine Ausnahme abfangen, aber eine andere auslösen möchten, sollten Sie die ursprüngliche Ausnahme in der neuen Ausnahme schachteln.</span><span class="sxs-lookup"><span data-stu-id="92183-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="92183-245">Dadurch kann ein Benutzer weiter unten im Stapel als `$PSItem.Exception.InnerException` darauf zugreifen.</span><span class="sxs-lookup"><span data-stu-id="92183-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="92183-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="92183-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="92183-247">Das Einzige, was mir an der Verwendung von `throw` für unformatierte Ausnahmen nicht gefällt, ist, dass die Fehlermeldung auf die `throw`-Anweisung verweist und angibt, dass sich das Problem in dieser Zeile befindet.</span><span class="sxs-lookup"><span data-stu-id="92183-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="92183-248">Wenn ich die Fehlermeldung bekomme, dass mein Skript fehlerhaft ist, weil ich `throw` in Zeile 31 angerufen habe, ist das für die Benutzer Ihres Skripts eine schlechte Meldung.</span><span class="sxs-lookup"><span data-stu-id="92183-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="92183-249">Sie erhalten dadurch keine hilfreichen Informationen.</span><span class="sxs-lookup"><span data-stu-id="92183-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="92183-250">Dexter Dhami hat darauf hingewiesen, dass ich `ThrowTerminatingError()` verwenden kann, um dies zu korrigieren.</span><span class="sxs-lookup"><span data-stu-id="92183-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="92183-251">Wenn wir davon ausgehen, dass `ThrowTerminatingError()` innerhalb einer Funktion mit dem Namen `Get-Resource` aufgerufen wurde, sollten wir diesen Fehler sehen.</span><span class="sxs-lookup"><span data-stu-id="92183-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="92183-252">Sehen Sie, wie sie auf die `Get-Resource`-Funktion als Quelle des Problems verweist?</span><span class="sxs-lookup"><span data-stu-id="92183-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="92183-253">Das sind hilfreiche Informationen für den Benutzer.</span><span class="sxs-lookup"><span data-stu-id="92183-253">That tells the user something useful.</span></span>

<span data-ttu-id="92183-254">Da `$PSItem` ein `ErrorRecord` ist, können wir `ThrowTerminatingError` auch auf diese Weise zum erneuten Auslösen verwenden.</span><span class="sxs-lookup"><span data-stu-id="92183-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="92183-255">Dadurch wird die Fehlerquelle in das Cmdlet geändert und die Interna Ihrer Funktion vor den Benutzern Ihres Cmdlets ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="92183-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="92183-256">Try kann Fehler mit Abbruch erstellen</span><span class="sxs-lookup"><span data-stu-id="92183-256">Try can create terminating errors</span></span>

<span data-ttu-id="92183-257">Kirk Munro zeigt, dass einige Ausnahmen nur bei der Ausführung innerhalb eines `try/catch`-Blocks Fehler mit Abbruch sind.</span><span class="sxs-lookup"><span data-stu-id="92183-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="92183-258">Er hat mir dieses Beispiel gegeben, das eine „Division durch Null“-Laufzeitausnahme generiert.</span><span class="sxs-lookup"><span data-stu-id="92183-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="92183-259">Führen Sie den Aufruf so aus. Sie sehen dann, dass der Fehler generiert und die Meldung trotzdem ausgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="92183-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="92183-260">Wenn Sie jedoch denselben Code in einem `try/catch` einfügen, passiert etwas anderes.</span><span class="sxs-lookup"><span data-stu-id="92183-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="92183-261">Der Fehler wird ein Fehler mit Abbruch, und die erste Meldung wird nicht ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="92183-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="92183-262">Was mir daran nicht gefällt, ist, dass Sie diesen Code in einer Funktion verwenden können, und er verhält sich anders, wenn jemand `try/catch`verwendet.</span><span class="sxs-lookup"><span data-stu-id="92183-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="92183-263">Ich selbst hatte damit keine Probleme, aber es ist ein Fall, den man kennen muss.</span><span class="sxs-lookup"><span data-stu-id="92183-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="92183-264">$PSCmdlet.ThrowTerminatingError() in try/catch</span><span class="sxs-lookup"><span data-stu-id="92183-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="92183-265">Eine Besonderheit von `$PSCmdlet.ThrowTerminatingError()` besteht darin, dass ein Fehler mit Abbruch innerhalb Ihres Cmdlets erstellt wird, der jedoch nach Verlassen des Cmdlets in einen Fehler ohne Abbruch umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="92183-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="92183-266">Dadurch muss der Aufrufer ihrer Funktion entscheiden, wie der Fehler behandelt werden soll.</span><span class="sxs-lookup"><span data-stu-id="92183-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="92183-267">Er kann ihn mit `-ErrorAction Stop` wieder in einen Fehler mit Abbruch umwandeln, oder ihn innerhalb von `try{...}catch{...}` aufrufen.</span><span class="sxs-lookup"><span data-stu-id="92183-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="92183-268">Öffentliche Funktionsvorlagen</span><span class="sxs-lookup"><span data-stu-id="92183-268">Public function templates</span></span>

<span data-ttu-id="92183-269">Eine letzte Sache, die ich aus meinem Gespräch mit Kirk Munro mitgenommen habe, war, dass er bei alle seinen erweiterten Funktionen um jeden `begin`-, `process`- und `end`-Block einen `try{...}catch{...}` einfügt.</span><span class="sxs-lookup"><span data-stu-id="92183-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="92183-270">In diesen allgemeinen Catch-Blöcken verwendet er eine einzige Zeile mit `$PSCmdlet.ThrowTerminatingError($PSItem)`, um alle Ausnahmen zu behandeln, die seine Funktionen verlassen.</span><span class="sxs-lookup"><span data-stu-id="92183-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="92183-271">Da alles in einer `try`-Anweisung innerhalb seiner Funktionen steht, wird alles einheitlich ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="92183-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="92183-272">Dadurch erhält der Endbenutzer auch eindeutige Fehler, die den internen Code vor dem generierten Fehler ausblendet.</span><span class="sxs-lookup"><span data-stu-id="92183-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="92183-273">Trap</span><span class="sxs-lookup"><span data-stu-id="92183-273">Trap</span></span>

<span data-ttu-id="92183-274">Ich haben mich auf den `try/catch`-Aspekt der Ausnahmen konzentriert.</span><span class="sxs-lookup"><span data-stu-id="92183-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="92183-275">Aber es gibt ein altes Feature, das ich erwähnen muss, bevor wir das Thema zusammenfassen.</span><span class="sxs-lookup"><span data-stu-id="92183-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="92183-276">Ein `trap` wird in einem Skript oder einer Funktion eingefügt, um alle Ausnahmen abzufangen, die in diesem Bereich auftreten.</span><span class="sxs-lookup"><span data-stu-id="92183-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="92183-277">Wenn eine Ausnahme auftritt, wird der Code im `trap` ausgeführt, und anschließend wird der normale Code fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="92183-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="92183-278">Wenn mehrere Ausnahmen auftreten, wird der Trap immer wieder aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="92183-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="92183-279">Ich persönlich habe diesen Ansatz nie verwendet, kann aber den Nutzen in Admin- oder Controllerskripts sehen, die alle Ausnahmen protokollieren und dann trotzdem weiter ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="92183-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="92183-280">Abschließende Hinweise</span><span class="sxs-lookup"><span data-stu-id="92183-280">Closing remarks</span></span>

<span data-ttu-id="92183-281">Durch das Hinzufügen einer richtigen Ausnahmebehandlung zu Ihren Skripts werden diese nicht nur stabiler, sondern es wird Ihnen auch die Fehlerbehebung für diese Ausnahmen erleichtert.</span><span class="sxs-lookup"><span data-stu-id="92183-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="92183-282">Ich habe lange über `throw` gesprochen, da dies eines der Kernkonzepte der Ausnahmebehandlung ist.</span><span class="sxs-lookup"><span data-stu-id="92183-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="92183-283">PowerShell bietet uns auch `Write-Error`, mit dem alle Situationen behandelt werden können, in denen Sie `throw` verwenden würden.</span><span class="sxs-lookup"><span data-stu-id="92183-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="92183-284">Denken Sie also nicht, dass Sie `throw` verwenden müssen, nachdem Sie das hier gelesen haben.</span><span class="sxs-lookup"><span data-stu-id="92183-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="92183-285">Nachdem ich mir nun die Zeit genommen habe, die Ausnahmebehandlung ausführlich zu beschreiben, werde ich nun zur Verwendung von `Write-Error -Stop` wechseln, um Fehler in meinem Code zu generieren.</span><span class="sxs-lookup"><span data-stu-id="92183-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="92183-286">Ich werde auch den Rat von Kirk übernehmen und `ThrowTerminatingError` als-Ausnahmehandler für jede Funktion verwenden.</span><span class="sxs-lookup"><span data-stu-id="92183-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[Originalversion]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Reddit/r/PowerShell-Community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Die lange Liste der .NET-Ausnahmen]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: https://docs.microsoft.com/dotnet/api/System.IO.FileNotFoundException
[.NET-Dokumentation]: https://docs.microsoft.com/dotnet/api
[.NET documentation]: https://docs.microsoft.com/dotnet/api
